# StructRef
The complex biological systems can be refined through an iterative refinement
process. Two types of refinement can be implemented on a biological model,
namely data refinement and process refinement. We develop here a software
for the reaction based-models, based on the data refinement method, where
some of its species are substituted with their subspecies. The software is
intended for generating the refined model as output after fetching the original
model. For verifying our software, we take the heat shock response model as
our case study. The software we implement produces the same result as the
case study.
#######[Webpage!](http://fshokri.github.io/StructRef)

### Implementation
Our software is divided in two parts: back-end and front-end, which refer to
the refinement source code and the user interface, respectively.
#### 1.Back-end
The software requires the user to enter one input file
with the SBML file format, which is followed by four outputs.
Here we provide the detailed description of our outputs.

#####1.1 Extracting species
In order to produce the first output, we read the input file and extract all the
species, then we write them in the output file, Species.xml by default.
It is worth mentioning that "HSRbasic.sbml" is our input file.
The functions which are used for the first output are *def extract_species(filename)* and
*def write_species(dict_species, filename)*.

#####1.2 Generating atomic refinement
In order to define a default refinement for each atomic species, we manipulate the
following function, *def write_atomic_refinement(in_file,out_file)* and *def read_atomic_refinement(filename)* which leads to our second output with XML file format, namely atomic-refinement.xml by default.

#####1.3 Generating complex refinement
In order to construct the refinement of complex species, we manipulate three functions
to serve this purpose. The complex refinement is generated by utilizing the
two XML files presented before. The functions which are used to create, are *complex_refinement.XML output*,
*def generate_complex_refinement(file, f)* and *def read_complex_refinement(filename)*.

#####1.4 Building the refined model
After generating our outputs namely species, atomic refinement, complex refinement,
we are able to create the refined model. The functions *def read_reactions(filename)*, *def generate_reactions(reactions,dict_complex_refinement_read)* and
*def write_refined_model(dic_species,dic_atomic,dic_complex,dic_reaction,fname)* are used for this purpose.

#####1.5 Displaying models
In order to present the chemical reactions of models, we define the *def print_chemical_reaction(filename)* function.
As a result, the user can be able to check all the reactions, and note the
transformation of species from reactants to products. It is worth mentioning that
the function is capable of displaying the original model or the refined model.

####2. Front-end
In order to present our intermediate steps for refinement development, we utilized
Qt designer for generating the user interface.

#####2.1 Designing the user interface
Qt Designer is the tool used for creating graphical user interfaces, by using Qt
components. We can customize our widgets or dialogs in any way we want
to implement our idea. Here we save as "UI.ui". As can be seen from the filename extension, we cannot
bind it to our source code. As a result, we should convert the file to .PY in order
to utilize it.

#####2.2 Binding the code
To manipulate our generated user interface, we need to convert it to .py filename
extension. With typing this command in Command Prompt/Terminal *"pyuic4 -o OutFile_ui.py InFile.ui"*, the **UI.py**
will be generated. After generating the code for the user interface with the filename extension
.py, we need to create another Python file for binding the user interface code and
the refinement source code, that we called **main.py**. And then we import our user
interface and source code as the module in the binder code.

#####2.3 Using the software

The requirement for running the software is having the Windows or Linux operating
system providing the Python and PyQt are installed. After compiling the
binder that is main.py, we should get the executed form of application.
we provide default filenames for outputs,
namely *Species.xml*, *Atomic_refinment.xml*, *Complex_refinment.xml* and *Refined_model.sbml*

which are removable and the user can define customized filenames. When users
enter the input filename for the Initial model, the users can present chemical
reaction of the model by clicking the Display button. By use of the Edit button,
modelers are able to modify the file and save changes, then by the View button
they can view the file in a browser according to platform either Windows or Linux.
In the next step, for generating species, the modeler can utilize the default
filename which is provided in the second LineEdit or opt for a customized one. By
clicking the Generate button, the user should observe the output in the current
folder according to the filename which is defined in the second LineEdit. Moreover,
the modeler can modify the output file for instance Species.XML by clicking the
Edit button. We define Edit function based on the three
platforms Mac, Linux, and Windows. According to Windows platform modelers,
can open the file in Word Pad for editing. In the Word Pad, users can update
the name or count of corresponding species and then save the modification to
be usable in further steps. Moreover, we designed the View buttons in order to
enable modelers view the output file after modification. According to the platform
modelers are running the software on, they can open the aforementioned output
file in the corresponding browser. And they can observe the latest changes in the
file.
We follow the same approach as output file *Species.xml* for the two other outputs namely *Atomic_refinment.xml* and *Complex_refinment.xml*. By clicking generate button for Atomic_refinment.xml, our
second output file will be produced in the current folder. In case of Linux platform,
user is able to open the Atomic_refinment file in text editor for instance Note Pad
by Edit button. In the editor, modelers can increase the number of the instance
for the desired species according to their case study. After modification, they can
view the output file in the firefox browser by clicking View buttons providing
having Linux platform.
For the Complex_refinment.xml, modelers can generate this file by clicking
Generate button which can be edited by Edit button. In the editor, modelers
are able to update the complex speciesâ€™ name and save the changes. And then
they can be sure that every change is applied by checking the file through the web
browser.
The Refined_model.sbml is considered as final output file with the same file
format as our input. Furthermore, The method of use of final output in software
is different from other outputs since we have the different buttons for it namely
Generate, Display and View. After generating the refined model, the modeler
has no option to modify the model as there is no Edit button defined for that.
