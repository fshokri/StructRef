# StructRef
The complex biological systems can be refined through an iterative refinement
process. Two types of refinement can be implemented on a biological model,
namely data refinement and process refinement. We develop here a software
for the reaction based-models, based on the data refinement method, where
some of its species are substituted with their subspecies. The software is
intended for generating the refined model as output after fetching the original
model. For verifying our software, we take the heat shock response model as
our case study. The software we implement produces the same result as the
case study.

### Implementation
Our software is divided in two parts: back-end and front-end, which refer to
the refinement source code and the user interface, respectively.
#### 1.Back-end
The software requires the user to enter one input file
with the SBML file format, which is followed by four outputs.
Here we provide the detailed description of our outputs.

#####1.1 Extracting species
In order to produce the first output, we read the input file and extract all the
species, then we write them in the output file, Species.xml by default.
It is worth mentioning that "HSRbasic.sbml" is our input file.
The functions which are used for the first output are *def extract_species(filename)* and
*def write_species(dict_species, filename)*.

#####1.2 Generating atomic refinement
In order to define a default refinement for each atomic species, we manipulate the
following function, *def write_atomic_refinement(in_file,out_file)* and *def read_atomic_refinement(filename)* which leads to our second output with XML file format, namely atomic-refinement.xml by default.

#####1.3 Generating complex refinement
In order to construct the refinement of complex species, we manipulate three functions
to serve this purpose. The complex refinement is generated by utilizing the
two XML files presented before. The functions which are used to create, are *complex_refinement.XML output*,
*def generate_complex_refinement(file, f)* and *def read_complex_refinement(filename)*.

#####1.4 Building the refined model
After generating our outputs namely species, atomic refinement, complex refinement,
we are able to create the refined model. The functions *def read_reactions(filename)*, *def generate_reactions(reactions,dict_complex_refinement_read)* and
*def write_refined_model(dic_species,dic_atomic,dic_complex,dic_reaction,fname)* are used for this purpose.

#####1.5 Displaying models
In order to present the chemical reactions of models, we define the *def print_chemical_reaction(filename)* function.
As a result, the user can be able to check all the reactions, and note the
transformation of species from reactants to products. It is worth mentioning that
the function is capable of displaying the original model or the refined model.

####2. Front-end
In order to present our intermediate steps for refinement development, we utilized
Qt designer for generating the user interface.

#####2.1 Designing the user interface
Qt Designer is the tool used for creating graphical user interfaces, by using Qt
components. We can customize our widgets or dialogs in any way we want
to implement our idea. Here we save as "UI.ui". As can be seen from the filename extension, we cannot
bind it to our source code. As a result, we should convert the file to .PY in order
to utilize it.

#####2.2 Binding the code
To manipulate our generated user interface, we need to convert it to .py filename
extension. With 
