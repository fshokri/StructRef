{"name":"Structref","tagline":"Software for generating data refinement of reaction-based models","body":"# StructRef\r\nThe complex biological systems can be refined through an iterative refinement\r\nprocess. Two types of refinement can be implemented on a biological model,\r\nnamely data refinement and process refinement. We develop here a software\r\nfor the reaction based-models, based on the data refinement method, where\r\nsome of its species are substituted with their subspecies. The software is\r\nintended for generating the refined model as output after fetching the original\r\nmodel. For verifying our software, we take the heat shock response model as\r\nour case study. The software we implement produces the same result as the\r\ncase study.\r\n\r\n### Implementation\r\nOur software is divided in two parts: back-end and front-end, which refer to\r\nthe refinement source code and the user interface, respectively.\r\n#### 1.Back-end\r\nThe software requires the user to enter one input file\r\nwith the SBML file format, which is followed by four outputs.\r\nHere we provide the detailed description of our outputs.\r\n\r\n#####1.1 Extracting species\r\nIn order to produce the first output, we read the input file and extract all the\r\nspecies, then we write them in the output file, Species.xml by default.\r\nIt is worth mentioning that \"HSRbasic.sbml\" is our input file.\r\nThe functions which are used for the first output are *def extract_species(filename)* and\r\n*def write_species(dict_species, filename)*.\r\n\r\n#####1.2 Generating atomic refinement\r\nIn order to define a default refinement for each atomic species, we manipulate the\r\nfollowing function, *def write_atomic_refinement(in_file,out_file)* and *def read_atomic_refinement(filename)* which leads to our second output with XML file format, namely atomic-refinement.xml by default.\r\n\r\n#####1.3 Generating complex refinement\r\nIn order to construct the refinement of complex species, we manipulate three functions\r\nto serve this purpose. The complex refinement is generated by utilizing the\r\ntwo XML files presented before. The functions which are used to create, are *complex_refinement.XML output*,\r\n*def generate_complex_refinement(file, f)* and *def read_complex_refinement(filename)*.\r\n\r\n#####1.4 Building the refined model\r\nAfter generating our outputs namely species, atomic refinement, complex refinement,\r\nwe are able to create the refined model. The functions *def read_reactions(filename)*, *def generate_reactions(reactions,dict_complex_refinement_read)* and\r\n*def write_refined_model(dic_species,dic_atomic,dic_complex,dic_reaction,fname)* are used for this purpose.\r\n\r\n#####1.5 Displaying models\r\nIn order to present the chemical reactions of models, we define the *def print_chemical_reaction(filename)* function.\r\nAs a result, the user can be able to check all the reactions, and note the\r\ntransformation of species from reactants to products. It is worth mentioning that\r\nthe function is capable of displaying the original model or the refined model.\r\n\r\n####2. Front-end\r\nIn order to present our intermediate steps for refinement development, we utilized\r\nQt designer for generating the user interface.\r\n\r\n#####2.1 Designing the user interface\r\nQt Designer is the tool used for creating graphical user interfaces, by using Qt\r\ncomponents. We can customize our widgets or dialogs in any way we want\r\nto implement our idea. Here we save as \"UI.ui\". As can be seen from the filename extension, we cannot\r\nbind it to our source code. As a result, we should convert the file to .PY in order\r\nto utilize it.\r\n\r\n#####2.2 Binding the code\r\nTo manipulate our generated user interface, we need to convert it to .py filename\r\nextension. With typing this command in Command Prompt/Terminal *\"pyuic4 -o OutFile_ui.py InFile.ui\"*, the **UI.py**\r\nwill be generated. After generating the code for the user interface with the filename extension\r\n.py, we need to create another Python file for binding the user interface code and\r\nthe refinement source code, that we called **main.py**. And then we import our user\r\ninterface and source code as the module in the binder code.\r\n\r\n#####2.3 Using the software\r\n\r\nThe requirement for running the software is having the Windows or Linux operating\r\nsystem providing the Python and PyQt are installed. After compiling the\r\nbinder that is main.py, we should get the executed form of application.\r\nwe provide default filenames for outputs,\r\nnamely *Species.xml*, *Atomic_refinment.xml*, *Complex_refinment.xml* and *Refined_model.sbml*\r\n\r\nwhich are removable and the user can define customized filenames. When users\r\nenter the input filename for the Initial model, the users can present chemical\r\nreaction of the model by clicking the Display button. By use of the Edit button,\r\nmodelers are able to modify the file and save changes, then by the View button\r\nthey can view the file in a browser according to platform either Windows or Linux.\r\nIn the next step, for generating species, the modeler can utilize the default\r\nfilename which is provided in the second LineEdit or opt for a customized one. By\r\nclicking the Generate button, the user should observe the output in the current\r\nfolder according to the filename which is defined in the second LineEdit. Moreover,\r\nthe modeler can modify the output file for instance Species.XML by clicking the\r\nEdit button. We define Edit function based on the three\r\nplatforms Mac, Linux, and Windows. According to Windows platform modelers,\r\ncan open the file in Word Pad for editing. In the Word Pad, users can update\r\nthe name or count of corresponding species and then save the modification to\r\nbe usable in further steps. Moreover, we designed the View buttons in order to\r\nenable modelers view the output file after modification. According to the platform\r\nmodelers are running the software on, they can open the aforementioned output\r\nfile in the corresponding browser. And they can observe the latest changes in the\r\nfile.\r\nWe follow the same approach as output file *Species.xml* for the two other outputs namely *Atomic_refinment.xml* and *Complex_refinment.xml*. By clicking generate button for Atomic_refinment.xml, our\r\nsecond output file will be produced in the current folder. In case of Linux platform,\r\nuser is able to open the Atomic_refinment file in text editor for instance Note Pad\r\nby Edit button. In the editor, modelers can increase the number of the instance\r\nfor the desired species according to their case study. After modification, they can\r\nview the output file in the firefox browser by clicking View buttons providing\r\nhaving Linux platform.\r\nFor the Complex_refinment.xml, modelers can generate this file by clicking\r\nGenerate button which can be edited by Edit button. In the editor, modelers\r\nare able to update the complex speciesâ€™ name and save the changes. And then\r\nthey can be sure that every change is applied by checking the file through the web\r\nbrowser.\r\nThe Refined_model.sbml is considered as final output file with the same file\r\nformat as our input. Furthermore, The method of use of final output in software\r\nis different from other outputs since we have the different buttons for it namely\r\nGenerate, Display and View. After generating the refined model, the modeler\r\nhas no option to modify the model as there is no Edit button defined for that.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}